# Python

## With

- `with ~ as ~` 구문은 주로 파일을 열고 닫을 때 사용한다고 한다. 

```python
with open(path+"/"+"test_data.txt", "r", encoding='utf-8') as f:
    firstline = f.readline()
    print(firstline)
```

- 위와 같이 with as 구문이 끝나면 메모리 해제가 자동으로 된다.

- 의문 - 파이썬은 GC가 없나? 메모리 해제를 직접 하는 시스템 프로그래밍 언어가 아니지 않나? 파일 여는 것 외에도 사용이 되는 것 같은데 우선 파일을 여는 데에 메모리 사용이 어떻게 되는지도 한번 알아보자.

- 우선 open() 함수 자체가 다른 언어에서 파일 여는 것과 같이 close()를 동반 해야 하는 함수라고 한다. 하긴 sys 라이브러리에서 쓰는 함수이니... 시스템 콜과 사용이 다르지 않은게 맞을 것 같다..

- url을 호출하는 경우에도 with 구문을 사용하는데... 이 예시는 fetch를 사용해서인가? fetch는 파일을 여는 데에도 사용을 하고 동작 방식이 비슷하고 다른 URL, API 호출과 fetch는 방식이 다르다면...

## Python GC

- 파이썬의 가비지 컬렉터는 레퍼런스 카운팅을 기준으로 메모리를 관리한다. 참조 횟수가 0이 된 객체를 메모리에서 해제한다.

- 참조 횟수가 0이 아니더라도 0에 도달할 수 없는 순환 참조 상황도 해결한다.

- refConut의 기본값이 문자열은 13, 리스트는 2, 정수는 189로 나오는데 이건 뭐지...?

- 일단 위 의문점은 시스템 콜 open과 같기 때문으로 결론이 났고 GC 공부는 지금 필요하지 않으니 넘어가자.

# asyncio

- 파이썬에서 비동기 함수, 코루틴을 사용할 수 있게 해주는 라이브러리

- `async def [함수명]()`으로 비동기 함수를 선언할 수 있다.

- `asyncio.create_task([비동기 함수])`로 코루틴을 생성한다.

- main 스레드에서 `await`로 생성한 코루틴을 실행한다.

- 코루틴 내에서 다른 코루틴을 호출한다면 await를 사용해서 그 코루틴의 종료를 기다린다. 

- 코루틴은 병렬 프로그래밍이 아니고 동시성 처리이다. 멀티 프로세싱, 스레딩처럼 오고 가는 방식으로 순차 실행되지만 스레드 보다 가볍고 자원 사용이 적고 그 속도가 더 빨라 동시에 처리되는 것 처럼 보인다. 

# GIL (Global Interpreter Lock)

- GIL은 뮤텍스와 같은 경쟁 상태를 막기 위해 한번에 하나의 스레드만 실행될 수 있도록 하는 Lock이다.

- GIL에 의해서 병렬 프로그래밍이 불가능 했다. 코드 구현이 불가능한 것은 아니지만 병렬 프로그래밍을 통한 성능 향상을 기대할 수 없다.

- GIL의 등장 배경은 메모리 관련 문제의 예방으로 파이썬 GC는 이전에 본 것과 같이 레퍼런스 카운팅을 기준으로 메모리를 해제하는데 여기서 경쟁 상태가 생겨서 여러 스레드가 한 변수의 참조를 동시에 늘려서 0이 되지 않거나(?_이건 불확실) 0을 만들어 해제되게 만들거나 하는 문제를 방지하고자 나온게 GIL이다.

- GIL에 의해 두 스레드가 한 변수에 접근해 숫자를 같이 줄이는 코드가 실행 시간이 오히려 더 긴 것을 확인할 수 있다.